{"componentChunkName":"component---src-templates-blog-template-js","path":"/articles/2020-01-16-prototyping-a-relational-saas-backend-using-responder-and-edgedb","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Prototyping a SaaS Backend with Responder and EdgeDB","date":"2020-01-16 21:17 -0400","description":"Building a backend is hard, especially when bootstrapping a SaaS. Here's how to handle the auth part, using Responder and EdgeDB.","keywords":["SaaS","EdgeDB","Authentication","Responder","Python"]},"html":"<p>This guide is best for people who want to get started with bootstrapping a SaaS in a fast manner, but with a relational database. There are a number of reasons to pick a relational database over a NoSQL database, but we won't go over them here.</p>\n<p>We are going to use <a href=\"https://responder.kennethreitz.org/en/latest/index.html\">responder</a>, a web and API framework, developed by Kenneth Reitz to interface with our database, <a href=\"https://edgedb.com\">EdgeDB</a>, by <a href=\"http://magic.io\">magicstack</a>. These were picked because of their relative simplicity and easiness to learn.</p>\n<h2>Initial API setup</h2>\n<p>To start, you should install a python package manager for your system. The one I recommend, is <code class=\"language-text\">pipenv</code> as it allows you to easily port and share your projects with other people. <a href=\"https://pipenv.kennethreitz.org/en/latest/\">Pipenv</a> can be downloaded from PyPa or your system package manager.</p>\n<p>Once you have pipenv set up, you should install our required packages. We will be using three, <code class=\"language-text\">responder</code>, <code class=\"language-text\">edgedb</code>, and <code class=\"language-text\">validators</code>. Validators takes care of some basic data and form validation for us.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">pipenv <span class=\"token function\">install</span> responder edgedb validators</code></pre></div>\n<p>We now have the libraries neccesary for establishing our python API. We can now create a file, called <em>main.py</em> to house our API code. It really doesn't matter what this file name is, so feel free to change it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">touch main.py</code></pre></div>\n<p>Responder is an ASGI framework, which means that we can do asynchronous operations. To create a basic responder app, we can follow the tutorial and define a simple endpoint.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> responder\n\napi <span class=\"token operator\">=</span> responder<span class=\"token punctuation\">.</span>API<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token decorator annotation punctuation\">@api<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/{greeting}\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">def</span> <span class=\"token function\">greet_world</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    resp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>greeting<span class=\"token punctuation\">}</span></span><span class=\"token string\">, world!\"</span></span>\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n    api<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Let's go over this code line by line.</p>\n<p><code class=\"language-text\">import responder</code> imports the responder library, so that we can use it later.</p>\n<p><code class=\"language-text\">api = responder.API()</code> establishes a responder app that we can run.</p>\n<p><code class=\"language-text\">@api.route(&quot;/{greeting}&quot;)</code> declares that this API has an endpoint or route. If you're unsure of what an endpoint is, then think of it as a specific page or pattern of pages. The route we're setting up here is dynamic, and pattern-based. The variable, <code class=\"language-text\">greeting</code> is enclosed in curly brackets to show that this is a dynamic route.</p>\n<p><code class=\"language-text\">async def greet_world(req, res, *, greeting):</code> declares a function that should run when a client (user) visits this endpoint. <code class=\"language-text\">greet_world</code> takes 4 paramaters, <code class=\"language-text\">req</code>, <code class=\"language-text\">res</code>, <code class=\"language-text\">*</code>, and <code class=\"language-text\">greeting</code>. <code class=\"language-text\">req</code> and <code class=\"language-text\">res</code> stand for request and response, and represent the data coming to the server and the data coming out. <code class=\"language-text\">*</code> is needed because we are using dynamic routes, which require an unknown amount of variables for endpoint patterns. <code class=\"language-text\">greeting</code> is a dynamic variable, which neccesitates <code class=\"language-text\">*</code>.</p>\n<p><code class=\"language-text\">resp.text = f&quot;{greeting}, world!</code> modifies the response object such that it's text will return a dynamic message based off <code class=\"language-text\">greeting</code>. You can learn more about request and response objects at <a href=\"https://requests.readthedocs.io/en/master/\">requests</a>.</p>\n<p><code class=\"language-text\">if __name__ == &#39;__main__&#39;:</code> uses some default python properties to establish that if this file is run, do what's below.</p>\n<p><code class=\"language-text\">api.run()</code> runs the app.</p>\n<p>We can now save this file and test to see whether our endpoint is working.</p>\n<p><code class=\"language-text\">pipenv run python3 main.py</code></p>\n<p>The default port that responder uses is <em>5042</em>, on localhost. You should be able to find it at <code class=\"language-text\">localhost:5042/&lt;some greeting you put in&gt;</code>.</p>\n<p>Now knowing that's working, we're going to shift towards setting up the database, before resuming working on the endpoints.</p>\n<h2>Database setup</h2>\n<p>EdgeDB is available for Unix, macOS, and docker. I've found that when I attempt to install EdgeDB on macOS that the package doesn't quite install properly given that this is still alpha software.</p>\n<p>The recommended method (and the way I did it) is through <a href=\"https://www.docker.com\">Docker</a>. If you are unsure of what docker is, I was unsure of it too, up until yesterday.</p>\n<p>Think of docker as an environment package manager, like pipenv. Instead of allowing us to port our project and it's environment, docker ports the entire operating system so that we can maintain better reproducibility. This is good for microservice architecture, where we may have many running parts that are tightly integrated with one another. It also makes docker cross-platform so any Windows users following this tutorial can continue.</p>\n<p>To use docker, you should download it using your appropriate system package manager or through the official docker website. If you're doing this on Windows or macOS, I recommend downloading it from the site.</p>\n<p>To download and enable it on Linux (particularly RHEL and SELinux based distros), you should run the following series of commands.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">sudo</span> dnf <span class=\"token function\">install</span> docker\n<span class=\"token function\">sudo</span> systemctl start docker</code></pre></div>\n<p>This installs and runs the docker service. Upon doing this, you should be able to run docker containers. Docker maintains a large repository of pre-created docker containers in a central location called the <a href=\"https://hub.docker.com\">Docker Hub</a>. This enables fast environment creation, as you are able to build upon and use other containers in your own.</p>\n<p>EdgeDB maintains a container at the Docker Hub. To get this container, you should run the following:</p>\n<p><code class=\"language-text\">docker pull edgedb/edgedb</code></p>\n<p>This pulls the official container, maintained by magicstack.</p>\n<p>To now run the container, we can follow the instructions given on the EdgeDB download site.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run --it --rm -p 5656:5656 -p 8888:8888 --name=edgedb-server -v &lt;datadir&gt;:/var/lib/edgedb/data edgedb/edgedb</code></pre></div>\n<p>You should replace <strong>&#x3C;datadir></strong> with the full path of a directory that you will use to store the edgedb data.</p>\n<p>If you're attempting to run this on any RHEL or SELinux based distro, like I was, you should add <code class=\"language-text\">--privileged</code> to get the docker container running.</p>\n<p>Now that we have an edgedb instance running, we should instantiate our database. We can instantiate it by opening up a CLI inside the database.</p>\n<p>Since we're running this in docker, we can't do this directly. What we need to do is spin up another docker instance containing this shell, that can connect to the database.</p>\n<p>This is done through a similar command.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run --link=edgedb-server --rm -it edgedb/edgedb:latest edgedb -u edgedb -h edgedb-server</code></pre></div>\n<p>If you're using a RHEL or SELinux based distro, add <code class=\"language-text\">--privileged</code> again.</p>\n<p>We now have an edgedb prompt and can instantiate a database.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE DATABASE saas_app;\n\\c saas_app</code></pre></div>\n<p>\\c is a command to connect to the database.</p>\n<p>The next thing to do is setup a schema for this database. If you don't know what a schema is, think of it as an outline of all the objects and things that go into this database and their relevant properties. We're gonna setup a really basic barebones schema.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">START TRANSACTION;\nCREATE MIGRATION  users TO {\n    type User {\n        required property email -&gt; str;\n        required property passwordHash -&gt; str;\n        required property active -&gt; bool;\n    }\n};\nCOMMIT MIGRATION users;\nCOMMIT;</code></pre></div>\n<p>I just threw alot at you, so I'll go over it line by line.</p>\n<p><code class=\"language-text\">START TRANSACTION</code> enables us to modify or change the schema.</p>\n<p><code class=\"language-text\">CREATE MIGRATION users TO {</code> is where we declare a data migration <em>users</em>, that is a change to the schema.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type User {\n    required property email -&gt; str;\n    required property passwordHash -&gt; str;\n    required property active -&gt; bool;\n}</code></pre></div>\n<p>This defines what object we're creating, its properties, and the type of its properties. We see here that we are defining a User model, with three properties, email, passwordHash, and active. Email and passwordHash are strings and active is a boolean. We require all of them.</p>\n<p><code class=\"language-text\">COMMIT MIGRATION users</code> makes the migration happen in the database.</p>\n<p><code class=\"language-text\">COMMIT</code> ends the transaction.</p>\n<hr>\n<p>If you, at any point in doing this, end up screwing up and get an error, do not fear.</p>\n<p><code class=\"language-text\">TransactionError: current transaction is aborted, commands ignored until end of transaction block</code></p>\n<p>Since an error happened, edgedb won't let the migration continue. To fix this, run a rollback.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ROLLBACK;</code></pre></div>\n<p>You can then start the migration / schema from the beginning again.</p>\n<hr>\n<p>Quitting the edgedb console is as simple as <code class=\"language-text\">\\q</code>.</p>\n<h2>Further API Setup</h2>\n<p>We can now move back to the python API we were setting up.</p>\n<p>A SaaS needs to have user accounts. This means that we need at minimum, two endpoints, <strong>/signup</strong> and <strong>/login</strong>. We can declare these routes and get rid of the greetings code from earlier.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> responder\n<span class=\"token keyword\">import</span> validators\n<span class=\"token keyword\">import</span> edgedb\n\napi <span class=\"token operator\">=</span> responder<span class=\"token punctuation\">.</span>API<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token decorator annotation punctuation\">@api<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/signup\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">def</span> <span class=\"token function\">signup</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> resp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token decorator annotation punctuation\">@api<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/login\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">def</span> <span class=\"token function\">login</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> resp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>You can see that we've removed the <code class=\"language-text\">*</code> and <code class=\"language-text\">greetings</code> parameters from earlier, because these are not going to be dynamic routes.</p>\n<p>We're gonna split up the writing of these methods into two parts, data validation, and database entry.</p>\n<h3>Data Validation</h3>\n<p>We can't be sure that whatever is being sent to this server is not malicious. We also have to be aware that users can make dumb mistakes and just do stupid stuff. In order to combat this, we need to implement a couple of measures to make it harder.</p>\n<p>The first thing we'll do is restrict the methods available for accessing this API. There are different HTTP methods for accessing a resource. We just want to allow requests that are are making POST requests, as they are sending us data that we respond back with. We can check if the request is of type POST with the following conditional:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> req<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">\"post\"</span><span class=\"token punctuation\">:</span></code></pre></div>\n<p>We check the client's request to ensure that it is of type post. POST must be lowercased, in order to meet responder's specs.</p>\n<p>We can put <code class=\"language-text\">pass</code> inside the if conditional, and return a different HTTP status code in the else statement. The full block looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> req<span class=\"token punctuation\">.</span>method <span class=\"token operator\">==</span> <span class=\"token string\">\"post\"</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    resp<span class=\"token punctuation\">.</span>status_code <span class=\"token operator\">=</span> api<span class=\"token punctuation\">.</span>status_codes<span class=\"token punctuation\">.</span>HTTP_405\n    resp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"405 Method Not Allowed\"</span>\n    <span class=\"token keyword\">return</span></code></pre></div>\n<p>We modify the response object that we'll send out to tell the client that the method in question is not allowed. You can find a full set of HTTP status codes on <a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\">Wikipedia</a>.</p>\n<p>If you'd like to return a different status code, you can change the number that's appended at the end of <code class=\"language-text\">api.status_codes</code> to match the error you'd like to send.</p>\n<p>The next step of validation is ensuring that whatever sent actually is what it's supposed to be. For <strong>/signup</strong> and <strong>/login</strong> that means two parameters.</p>\n<ul>\n<li>email</li>\n<li>passwordHash</li>\n</ul>\n<p>We need to make sure that <em>email</em> is actually an email. We can also impose a length max for <em>passwordHash</em> to ensure no flooding.</p>\n<p>This is where <a href=\"https://validators.readthedocs.io/en/latest/\"><strong>validators</strong></a>, the library I mentioned earlier, comes in. It's a no nonsense fast way to validate stuff, and isn't as complicated as other popular validation schema libraries.</p>\n<p>We first need to get the response content. Since <strong>responder</strong> is an asynchronous framework, we need to wait until all of the request is loaded. To do this, we need to use <code class=\"language-text\">await</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">info <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> req<span class=\"token punctuation\">.</span>media<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We await the data (<code class=\"language-text\">req.media()</code>) from the response. We can then get the field names and store them variables.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">email <span class=\"token operator\">=</span> info<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"email\"</span><span class=\"token punctuation\">)</span>\npasswordHash <span class=\"token operator\">=</span> info<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"passwordHash\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This done, we can now perform the data validation scheme.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> validators<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">(</span>email<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>passwordHash<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">32</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    resp<span class=\"token punctuation\">.</span>status_code <span class=\"token operator\">=</span> api<span class=\"token punctuation\">.</span>status_codes<span class=\"token punctuation\">.</span>HTTP_400\n    resp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"400 Bad Request\"</span>\n    <span class=\"token keyword\">return</span></code></pre></div>\n<p>This ensures that we are, in fact, getting an email, and that the passwordHash is a hash. We can now move on to data entry and connection.</p>\n<h3>Data Entry</h3>\n<p>We must first connect to our database. Relevant documention for the edgedb python driver is <a href=\"https://edgedb.com/docs/clients/00_python/usage\">here</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">conn <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> edgedb<span class=\"token punctuation\">.</span>async_connect<span class=\"token punctuation\">(</span><span class=\"token string\">'edgedb://edgedb@localhost/saas_app'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The nice thing about setting up edgeDB using docker, is that it instantiates a default database account to connect with. We will further deconstruct the connection string.</p>\n<p><code class=\"language-text\">edgedb://</code> is the protocol that states what database we're connecting to.</p>\n<p><code class=\"language-text\">edgedb</code> is the user.</p>\n<p><code class=\"language-text\">localhost</code> is the IP address for the database. In production, we'd need to change this.</p>\n<p><code class=\"language-text\">saas_app</code> is the name of our database.</p>\n<p>We can now work on the <strong>/signup</strong> endpoint. The signup endpoint requires that we take in the <strong>email</strong> and <strong>passwordHash</strong> and create a new user account if the email isn't already present. So we'll first check if the user is present.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">await</span> conn<span class=\"token punctuation\">.</span>fetchone<span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">'''\n    SELECT User {email} FILTER .email = &lt;str>$email\n    LIMIT 1\n'''</span><span class=\"token punctuation\">,</span> email<span class=\"token operator\">=</span>email<span class=\"token punctuation\">)</span></code></pre></div>\n<p>What this method, <code class=\"language-text\">fetchone</code> does, is fetch one result from the query. The query is <a href=\"https://edgedb.com/docs/edgeql/overview\">EdgeQL</a>, which is based off SQL. We select from our model <code class=\"language-text\">User</code> all objects with <code class=\"language-text\">email</code> where <code class=\"language-text\">email</code> matches the email we got from the request object.</p>\n<p>If it matches, we want to send a different response, and close the db connection.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">await</span> conn<span class=\"token punctuation\">.</span>fetchone<span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">'''\n        SELECT User {email} FILTER .email = &lt;str>$email\n        LIMIT 1\n    '''</span><span class=\"token punctuation\">,</span> email<span class=\"token operator\">=</span>email<span class=\"token punctuation\">)</span>\n    resp<span class=\"token punctuation\">.</span>status_code <span class=\"token operator\">=</span> api<span class=\"token punctuation\">.</span>status_codes<span class=\"token punctuation\">.</span>HTTP_400\n    resp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"400 Bad Request\"</span>\n    <span class=\"token keyword\">await</span> conn<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span>\n<span class=\"token keyword\">except</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">await</span> conn<span class=\"token punctuation\">.</span>fetchall<span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">'''\n        INSERT User {\n            email := &lt;str>$email,\n            passwordHash := &lt;str>$passwordHash,\n            active := &lt;bool>$active\n        }\n    '''</span><span class=\"token punctuation\">,</span> email<span class=\"token operator\">=</span>email<span class=\"token punctuation\">,</span> passwordHash<span class=\"token operator\">=</span>passwordHash<span class=\"token punctuation\">,</span> active<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">await</span> conn<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nresp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"Signup Complete!\"</span></code></pre></div>\n<p>Otherwise, we can proceed with signup. This is done through <code class=\"language-text\">fetchall</code>, and an <code class=\"language-text\">INSERT</code> query. If all goes well, we proceed to close the db connection and return a Response object that will print out \"Signup Complete!\".</p>\n<p>The <strong>/login</strong> endpoint is very similar to the <strong>/signup</strong> one. We keep the same try block, modifying it slightly.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n    user <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> conn<span class=\"token punctuation\">.</span>fetchone<span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">'''\n        SELECT User {email, passwordHash} FILTER .email = &lt;str>$email AND .passwordHash = &lt;str>$passwordHash\n        LIMIT 1\n    '''</span><span class=\"token punctuation\">,</span> email<span class=\"token operator\">=</span>email<span class=\"token punctuation\">,</span> passwordHash<span class=\"token operator\">=</span>passwordHash<span class=\"token punctuation\">)</span>\n    resp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"Login Successful\"</span>\n<span class=\"token keyword\">except</span><span class=\"token punctuation\">:</span>\n    resp<span class=\"token punctuation\">.</span>status_code <span class=\"token operator\">=</span> api<span class=\"token punctuation\">.</span>status_codes<span class=\"token punctuation\">.</span>HTTP_400\n    resp<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"Login Unsuccessful\"</span></code></pre></div>\n<p>We check to see if <code class=\"language-text\">email</code> and <code class=\"language-text\">passwordHash</code> match, and return successful if so. Otherwise, we throw another 400 bad request. We can proceed to close the database connection.</p>\n<h2>Testing</h2>\n<p>You now have an API endpoint connected to a database that is able to process signups and logins.</p>\n<p>You now need to move towards testing this API endpoint. I find <a href=\"https://www.getpostman.com\">Postman</a> to be an ideal tool for this sort of testing. You can also use the terminal and curl, but Postman really just makes it so much easier.</p>\n<p>You can create a POST request in Postman, and change the type of the body to be <code class=\"language-text\">xxx-form-encoded</code>. You can then include two keys, <code class=\"language-text\">email</code> and <code class=\"language-text\">passwordHash</code> and send out API requests in order to test whether your API is working. Remember to keep both the EdgeDB instance and responder server up when doing this.</p>\n<h2>Conclusion</h2>\n<p>You did it! If you appreciate this sort of content or have any sort of questions, please give me a follow on <a href=\"https://twitter.com/suchcaptcha\">twitter</a>.</p>"}},"pageContext":{"slug":"2020-01-16-prototyping-a-relational-saas-backend-using-responder-and-edgedb"}}}